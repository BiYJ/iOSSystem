//
//  Inline.h
//  NSObject
//
//  Created by CYKJ on 2019/11/21.
//  Copyright © 2019年 D. All rights reserved.


#import <Foundation/Foundation.h>

// .h 文件中的内联函数
inline static void inlineFunc(NSString * string)
{
    NSLog(@"%@", string);
}

/**
    调用 call 指令需要：
            ①、将下一条指令的所在地址入栈
            ②、并将子程序的起始地址送入 PC（于是 CPU 的下一条指令就会转去执行子程序）
 
     相比于函数：
            ①、inline 函数避免了普通函数在汇编时必须调用 call 的缺点：取消了函数的参数压栈，减少了调用的开销，提高效率，所以执行速度确比一般函数的执行速度要快。
            ②、集成了宏的优点，使用时直接用代码替换（像宏一样）。
 
    相比于宏：
            ①、避免了宏的缺点：宏需要预编译，因为 inline 内联函数也是函数，不需要预编译。
            ②、编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性；
            ③、可以使用所在类的保护成员及私有成员。
 
    弊端：
            ①、如果函数的代码较长，使用内联将消耗过多内存
            ②、如果函数体内有循环，那么执行函数代码时间比调用开销大。
 
     inline 内联函数说明：
        1、内联函数只是我们向编译器提供的申请，编译器不一定采取 inline 形式调用函数；
        2、内联函数不能承载大量的代码。如果内联函数的函数体过大，编译器会自动放弃内联；
        3、内联函数内不允许使用循环语句或开关语句；
        4、内联函数的定义须在调用之前；
        5、当使用内联函数时，如果在多处调用了此内联函数，则此函数就会有 N 次代码段的拷贝，所以多配合`static`标示符使用。

  */

@interface Inline : NSObject

- (void)dowork;

@end
